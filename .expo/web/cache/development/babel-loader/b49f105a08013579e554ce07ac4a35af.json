{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport Animated, { block, defined } from \"react-native-reanimated\";\nimport { max, min } from \"./Math\";\nvar Value = Animated.Value,\n    set = Animated.set,\n    add = Animated.add,\n    multiply = Animated.multiply,\n    cond = Animated.cond,\n    eq = Animated.eq,\n    abs = Animated.abs,\n    sub = Animated.sub,\n    not = Animated.not,\n    lessThan = Animated.lessThan,\n    greaterThan = Animated.greaterThan,\n    divide = Animated.divide,\n    modulo = Animated.modulo,\n    proc = Animated.proc;\nexport var diff = function diff(v) {\n  var stash = new Value(0);\n  var prev = new Value();\n  return block([set(stash, cond(defined(prev), sub(v, prev), 0)), set(prev, v), stash]);\n};\nexport var diffClamp = function diffClamp(a, minVal, maxVal) {\n  var value = new Value();\n  return set(value, min(max(add(cond(defined(value), value, a), diff(a)), minVal), maxVal));\n};\nexport var moving = function moving(position) {\n  var minPositionDelta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-3;\n  var emptyFrameThreshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n  var delta = diff(position);\n  var noMovementFrames = new Value(0);\n  return cond(lessThan(abs(delta), minPositionDelta), [set(noMovementFrames, add(noMovementFrames, 1)), not(greaterThan(noMovementFrames, emptyFrameThreshold))], [set(noMovementFrames, 0), 1]);\n};\nexport var snapPoint = function snapPoint(value, velocity, points) {\n  var point = add(value, multiply(0.2, velocity));\n\n  var diffPoint = function diffPoint(p) {\n    return abs(sub(point, p));\n  };\n\n  var deltas = points.map(function (p) {\n    return diffPoint(p);\n  });\n  var minDelta = min.apply(void 0, _toConsumableArray(deltas));\n  return points.reduce(function (acc, p) {\n    return cond(eq(diffPoint(p), minDelta), p, acc);\n  }, new Value());\n};\nexport var addTo = proc(function (value, node) {\n  return set(value, add(value, node));\n});\nexport var subTo = proc(function (value, node) {\n  return set(value, sub(value, node));\n});\nexport var multiplyTo = proc(function (value, node) {\n  return set(value, multiply(value, node));\n});\nexport var divideTo = proc(function (value, node) {\n  return set(value, divide(value, node));\n});\nexport var moduloTo = proc(function (value, node) {\n  return set(value, modulo(value, node));\n});","map":{"version":3,"sources":["Animations.ts"],"names":["Value","set","add","multiply","cond","eq","abs","sub","not","lessThan","greaterThan","divide","modulo","proc","Animated","diff","stash","prev","block","defined","diffClamp","value","min","max","moving","minPositionDelta","emptyFrameThreshold","delta","noMovementFrames","snapPoint","point","diffPoint","deltas","points","minDelta","addTo","subTo","multiplyTo","divideTo","moduloTo"],"mappings":"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","sourcesContent":["import Animated, { block, defined } from \"react-native-reanimated\";\n\nimport { max, min } from \"./Math\";\n\nconst {\n  Value,\n  set,\n  add,\n  multiply,\n  cond,\n  eq,\n  abs,\n  sub,\n  not,\n  lessThan,\n  greaterThan,\n  divide,\n  modulo,\n  proc,\n} = Animated;\n\nexport type SpringConfig = Partial<Omit<Animated.SpringConfig, \"toValue\">>;\nexport type TimingConfig = Partial<Omit<Animated.TimingConfig, \"toValue\">>;\n\n// currently diffClamp() from reanimated seems currently buggy because of proc()\nexport const diff = (v: Animated.Node<number>) => {\n  const stash = new Value(0);\n  const prev = new Value<number>();\n  return block([\n    set(stash, cond(defined(prev), sub(v, prev), 0)),\n    set(prev, v),\n    stash,\n  ]);\n};\n\nexport const diffClamp = (\n  a: Animated.Node<number>,\n  minVal: Animated.Adaptable<number>,\n  maxVal: Animated.Adaptable<number>\n) => {\n  const value = new Value<number>();\n  return set(\n    value,\n    min(max(add(cond(defined(value), value, a), diff(a)), minVal), maxVal)\n  );\n};\n\nexport const moving = (\n  position: Animated.Node<number>,\n  minPositionDelta = 1e-3,\n  emptyFrameThreshold = 5\n) => {\n  const delta = diff(position);\n  const noMovementFrames = new Value(0);\n  return cond(\n    lessThan(abs(delta), minPositionDelta),\n    [\n      set(noMovementFrames, add(noMovementFrames, 1)),\n      not(greaterThan(noMovementFrames, emptyFrameThreshold)),\n    ],\n    [set(noMovementFrames, 0), 1]\n  );\n};\n\nexport const snapPoint = (\n  value: Animated.Adaptable<number>,\n  velocity: Animated.Adaptable<number>,\n  points: Animated.Adaptable<number>[]\n) => {\n  const point = add(value, multiply(0.2, velocity));\n  const diffPoint = (p: Animated.Adaptable<number>) => abs(sub(point, p));\n  const deltas = points.map((p) => diffPoint(p));\n  const minDelta = min(...deltas);\n  return points.reduce(\n    (acc, p) => cond(eq(diffPoint(p), minDelta), p, acc),\n    new Value()\n  ) as Animated.Node<number>;\n};\n\nexport const addTo = proc(\n  (value: Animated.Value<number>, node: Animated.Adaptable<number>) =>\n    set(value, add(value, node))\n);\n\nexport const subTo = proc(\n  (value: Animated.Value<number>, node: Animated.Adaptable<number>) =>\n    set(value, sub(value, node))\n);\n\nexport const multiplyTo = proc(\n  (value: Animated.Value<number>, node: Animated.Adaptable<number>) =>\n    set(value, multiply(value, node))\n);\n\nexport const divideTo = proc(\n  (value: Animated.Value<number>, node: Animated.Adaptable<number>) =>\n    set(value, divide(value, node))\n);\n\nexport const moduloTo = proc(\n  (value: Animated.Value<number>, node: Animated.Adaptable<number>) =>\n    set(value, modulo(value, node))\n);\n"]},"metadata":{},"sourceType":"module"}